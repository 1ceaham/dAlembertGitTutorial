# Interactive tutorial
## Getting started with git
### Make a project directory
* `pwd`
* `mkdir myTestRepo`
* `cd myTestRepo`.

### Initialize a repo
* `git init`
* `ls -a`: presence of `.git`

### Add content
* `vi hello.sh` - Open a new file in vi (or vim) named `hello.sh`.
* `i` - Enter "Insert" mode.
* Type (or copy/paste, if your terminal supports that):
    ```
    #!/bin/bash
    echo "Hello world"
    ```
* `Esc` - Leave "Insert" mode.
* `:wq`, `Enter` - Issue the command "Write, then quit."
* `chmod +x hello.sh`
* `./hello.sh`

### See what git sees
* `git status`: "untracked"

### Stage files to be added / updated
`git add hello.sh`

Other wildcards:
* `*.txt` - nonrecursive
* `\*.txt` - subdir recursive
* `git add -A` - match working directory

### Ignore files
* `.gitignore`

### Take a snapshot
* `git status`
* `git commit -m "Initial commit."`

### Make a change
* `vi hello.sh` - Open the editor.
* `j` - We're in command mode, so this doesn't insert a character, but instead moves the cursor down a line.
* `llllllllllllllllll` - Move the cursor between `d` and `"`. If you overshoot, you can press `h` as many times as you need to go back the other way.
* `i` - Enter insert mode.
* `, I can use git!` - Enter some text.
* `Esc`, `:wq`, `Enter` - Return to command mode, save, and quit, as before.

### Test it and see what changed
* `./hello.sh`
* `git status`
* `git diff --word-diff hello.sh`

### Snapshot
* `git commit -a -m "Add qualifications."`.

### History and ancestor comparisons
* `git log`
* `git diff --word-diff HEAD~ HEAD hello.sh`
    * `HEAD~~~`: "the parent of the parent of the parent of `HEAD`"
    * `HEAD~4`
    * `HEAD@{yesterday}`
    * `1c002d` as shorthand for `1c002dd4b536e7479fe34593e72e6c6c1819e53b`

### Going back in time
**_DANGER ALERT:_** If you have uncommitted changes in your working directory, the following commands can destroy them, leading to lost work. Make sure you `git status` to make sure your working directory is clean!

* `git checkout HEAD~`
    * `'detached HEAD' state`
* `cat hello.sh`
* `git checkout master`.

### Reverting a change
* `git revert HEAD`: add a new commit "reversing" the last one 

## Working with remote repos
### Adding a remote and pushing
Make a new bare repo on GitHub
* ["New repository"](https://github.com/new) -> `myTestRepo`
* `git remote add origin https://github.com/Username/myTestRepo.git`
* `git push -u origin master*
* https://github.com/Username/myTestRepo.

### Make a change and send to remote
* `git push origin master`

### Pulling from a remote
* Check: `git fetch`
* Download: `git pull`

### Initializing a repo from a remote
* `git clone`

### What is this webpage?
This page was automagically generated by GitHub Pages from a repo that you can find [here](https://github.com/1ceaham/dAlembertGitTutorial). You can see the license for this page [below](#license).

## Collaboration
### Branches
Branches are basically a way to save and switch between different versions of the same repo. This can allow you to work on multiple ideas at the same time without having to worry about their dependencies. They are also often used as a way to distinguish the "doneness" of a given version of the repo.

For example, `master` (the default name of the branch you are on when initializing a repo) is often used as the "release" or "production-ready" branch, meaning it is always ready for end users to deploy. Conversely, `development` is often the "working" branch, where things are integrated and tested, and "feature branches" (which would be named after a given feature, like `add-pizza`) are where a singular idea is being worked on. The idea here is that it's painless to change between all of these (as long as everything is committed), so that you can context switch without having to think about file management.

Eventually, in this model, features that are finished (say you successfully `add-pizza`) get merged into `development`, and when all of the bugs have been ironed out and it's time to make a release, that is finally merged into `master` where most people will go to get the latest stable version of the codebase. The advantage of this workflow is that individual branches can progress at their own speed, and only have to be integrated at the point where they merge.

If you think back to earlier, when we went "back in time" by moving our `HEAD` reference to a previous commit, we had the option to begin a new series of commits on a branch. In one step, you can create and switch to that new branch with `git checkout -b <branchname>`. In this sense, you can think of branches as labels on particular commits in the history graph of your repository. When you go back to a commit and start a new branch (for a feature perhaps), you're essentially just adding a new label at that commit that you can refer to by name. When you then add a few new commits, the label comes along with you and stays at the tip of the branch. When that branch is eventually merged back in somewhere else, that label is concurrent with the label of the branch that it was merged into, and can therefore be deleted (though it will still be present in git's `reflog` history).

One final note is that people use branches for all kinds of things, and they don't even have to be related. Some [repos](https://en.wikipedia.org/wiki/Monorepo) will even contain multiple projects on different branches. At the end of the day, a branch is just a label for a particular commit, even if it has the "significance" of standing for all of the history between that commit and where it left a common ancestor. In fact, branches can even represent a snapshot without any ancestry: imagine a completely separate directory superimposed on the first, where all it takes to switch between the two is a `git switch <branchname>` (or `git checkout <branchname>` in older versions of git).

### GitHub "Fork and Pull" Model
Collaboration on GitHub often takes a branch-centered workflow as above. But what happens when you are not a collaborator on a repo you would like to contribute to? You can fork it (thus creating a copy under your own account), and assuming a permissive license, modify it however you like. Frequently, this part of the work is done just as above, with branches. Then, using the web interface, you can file a "Pull Request" to merge your forked, branched version back into the original repo. The owner can respond, perhaps offering comments or suggestions, and if they like the changes you've made, can bring them into the original repo.

### Other Methods
Of course, collaboration is not limited to these forms. Some groups use [mailing lists](https://en.wikipedia.org/wiki/Linux_kernel_mailing_list) to send [patches](https://git-send-email.io) via email, including comments, discussion, and logging. Some services introduce webhooks or enforce continuous integration (CI) rules that can automatically test, build, and deploy complex software projects, making it possible to fix a bug from your cell phone.

## More resources
Want to know how git actually works under the hood? [Git from the inside out](https://codewords.recurse.com/issues/two/git-from-the-inside-out). Hint: it's hashes all the way down.

[How to undo (almost) anything in git.](https://github.blog/2015-06-08-how-to-undo-almost-anything-with-git/) You know, just in case you make a mistake.

For reference, a [GitHub-written cheat sheet](https://github.github.com/training-kit/downloads/github-git-cheat-sheet/) with some useful definitions and reminders.

## License
[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).
